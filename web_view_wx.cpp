/*
 *                 Copyright (C) 2018, UChicago Argonne, LLC
 *                            All Rights Reserved
 *
 *                          Software Name: web_view
 *                      By: Argonne National Laboratory
 *                            OPEN SOURCE LICENSE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *   3. Neither the name of the copyright holder nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 * *****************************************************************************
 *                                 DISCLAIMER
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * *****************************************************************************
 */

#include <web_view.h>

#include <sstream>

#include <wx/wxprec.h>
#ifndef WX_PRECOMP
#include <wx/wx.h>
#endif

#if !wxUSE_WEBVIEW_WEBKIT && !wxUSE_WEBVIEW_WEBKIT2 && !wxUSE_WEBVIEW_IE
#error "A wxWebView backend is required"
#endif

#include <wx/webview.h>
#if wxUSE_WEBVIEW_IE
#include <wx/msw/webview_ie.h>
#endif
#include <wx/webviewfshandler.h>
#include <wx/filesys.h>

#include <web_view_wx_export.h> // Generated by CMake.

using namespace wv;

namespace {
  using namespace web_view_detail;

  static const int CMD_DISPLAY_URI = wxNewId();
  static const int CMD_RUN_SCRIPT = wxNewId();
  static const int CMD_REGISTER_SCHEME = wxNewId();
  static const int CMD_REGISTER_CLOSE = wxNewId();
  static const int CMD_REGISTER_AUX_CLOSE = wxNewId();
  static const int CMD_NEW_WEB_VIEW = wxNewId();
  static const int CMD_DEL_WEB_VIEW = wxNewId();

  struct WVSchemeHandler : public wxWebViewHandler {
    WVSchemeHandler(const wxString &scheme, HandlerFunc *func) :
      wxWebViewHandler(scheme), func(func) { }
    virtual ~WVSchemeHandler() { }

    virtual wxFSFile *GetFile(const wxString &uri) {
      std::ostringstream os;
      if (!(*func)(uri.ToStdString(), os))
        return nullptr;

      return new wxFSFile(new wxStringInputStream(os.str()), uri, "", "", wxDateTime::Now());
    }

    std::unique_ptr<HandlerFunc> func;
  };

  struct WVFrame : public wxFrame {
    WVFrame(const wxString &label);
    virtual ~WVFrame() { }

    void RegisterURIScheme(const wxString &scheme, HandlerFunc *func) {
      if (!browser)
        return;

      browser->RegisterHandler(wxSharedPtr<wxWebViewHandler>(new WVSchemeHandler(scheme, func)));
    }

    void DisplayHTMLFromURI(const std::string &uri, std::promise<std::error_code> *p) {
      if (prom)
        prom.release()->set_value(std::make_error_code(std::errc::operation_canceled));
      prom.reset(p);

      browser->LoadURL(uri);
    }

    void RunScript(const std::string &script, std::promise<std::string> *p) {
      wxString result;
      if (!browser->RunScript(script, &result))
        result = "";

      p->set_value(result.ToStdString());
    }

    void OnNavigationRequest(wxWebViewEvent &evt) { }
    void OnNavigationComplete(wxWebViewEvent &evt) { }
    void OnNewWindow(wxWebViewEvent &evt) { }

    void OnTitleChanged(wxWebViewEvent &evt) {
      if (evt.GetString().empty())
        SetTitle(base_label);
      else
        SetTitle(base_label + ": " + evt.GetString());
    }

    void OnDocumentLoaded(wxWebViewEvent &evt) {
      if (prom && evt.GetURL() == browser->GetCurrentURL())
        prom.release()->set_value(std::error_code());
    }

    void OnError(wxWebViewEvent &evt) {
      if (!prom)
        return;

      std::errc e = std::errc::invalid_argument;
      switch (evt.GetInt()) {
      case wxWEBVIEW_NAV_ERR_CONNECTION:
        e = std::errc::connection_reset;
        break;
      case wxWEBVIEW_NAV_ERR_CERTIFICATE:
      case wxWEBVIEW_NAV_ERR_AUTH:
      case wxWEBVIEW_NAV_ERR_SECURITY:
        e = std::errc::permission_denied;
        break;
      case wxWEBVIEW_NAV_ERR_NOT_FOUND:
        e = std::errc::no_such_file_or_directory;
        break;
      case wxWEBVIEW_NAV_ERR_REQUEST:
        e = std::errc::not_supported;
        break;
      case wxWEBVIEW_NAV_ERR_USER_CANCELLED:
        e = std::errc::operation_canceled;
        break;
      default:
        break;
      }

      prom.release()->set_value(std::make_error_code(e));
    }

    void RegisterClose(CloseHandlerFunc *f) {
      cfunc.reset(f);
    }

    void RegisterAuxClose(CloseHandlerFunc *f) {
      acfunc.reset(f);
    }

    void OnClose(wxCloseEvent &event) {
      if (cfunc)
        (*cfunc)();

      if (acfunc)
        (*acfunc)();
    }

    wxDECLARE_EVENT_TABLE();

    wxWebView* browser;
    wxString base_label;

    std::unique_ptr<std::promise<std::error_code>> prom;
    std::unique_ptr<CloseHandlerFunc> cfunc, acfunc;
  };

  wxBEGIN_EVENT_TABLE(WVFrame, wxFrame)
  EVT_CLOSE(WVFrame::OnClose)
  wxEND_EVENT_TABLE()

  WVFrame::WVFrame(const wxString &label)
    : wxFrame(NULL, wxID_ANY, label), browser(nullptr), base_label(label), prom(nullptr) {

    browser = wxWebView::New(this, wxID_ANY);

    wxSizer *sizer = new wxBoxSizer(wxVERTICAL);
    sizer->Add(browser, wxSizerFlags().Expand().Proportion(1));

    browser->EnableContextMenu(false);
    browser->EnableHistory(false);

    sizer->SetSizeHints(this);
    SetSizer(sizer);

    Bind(wxEVT_WEBVIEW_NAVIGATING, &WVFrame::OnNavigationRequest, this, browser->GetId());
    Bind(wxEVT_WEBVIEW_NAVIGATED, &WVFrame::OnNavigationComplete, this, browser->GetId());
    Bind(wxEVT_WEBVIEW_LOADED, &WVFrame::OnDocumentLoaded, this, browser->GetId());
    Bind(wxEVT_WEBVIEW_ERROR, &WVFrame::OnError, this, browser->GetId());
    Bind(wxEVT_WEBVIEW_NEWWINDOW, &WVFrame::OnNewWindow, this, browser->GetId());
    Bind(wxEVT_WEBVIEW_TITLE_CHANGED, &WVFrame::OnTitleChanged, this, browser->GetId());
  }

  struct NewWVData {
    std::promise<WVFrame *> frame_prom;
    std::string label;
  };

  struct DelWVData {
    WVFrame *frame;
  };

  struct RegSchemeData {
    WVFrame *frame;
    std::string scheme;
    HandlerFunc *func;
  };

  struct RegCloseData {
    WVFrame *frame;
    CloseHandlerFunc *cfunc;
  };

  struct DisplayURIData {
    std::promise<std::error_code> *prom;
    WVFrame *frame;
    std::string uri;
  };

  struct RunScriptData {
    std::promise<std::string> *prom;
    WVFrame *frame;
    std::string script;
  };

  struct WVApp : public wxApp {
    WVApp();

    void OnDisplayURI(wxThreadEvent& event) {
      DisplayURIData *d = event.GetPayload<DisplayURIData *>();
      d->frame->DisplayHTMLFromURI(d->uri, d->prom);
      delete d;
    }

    void OnRunScript(wxThreadEvent& event) {
      RunScriptData *d = event.GetPayload<RunScriptData *>();
      d->frame->RunScript(d->script, d->prom);
      delete d;
    }

    void OnRegisterScheme(wxThreadEvent& event) {
      RegSchemeData *d = event.GetPayload<RegSchemeData *>();
      d->frame->RegisterURIScheme(d->scheme, d->func);
      delete d;
    }

    void OnRegisterClose(wxThreadEvent& event) {
      RegCloseData *d = event.GetPayload<RegCloseData *>();
      d->frame->RegisterClose(d->cfunc);
      delete d;
    }

    void OnRegisterAuxClose(wxThreadEvent& event) {
      RegCloseData *d = event.GetPayload<RegCloseData *>();
      d->frame->RegisterAuxClose(d->cfunc);
      delete d;
    }

    void OnNewWebView(wxThreadEvent& event) {
      NewWVData *d = event.GetPayload<NewWVData *>();

      WVFrame *frame = new WVFrame(d->label);
      frame->Show();

      // Don't let the window get too small.
      frame->SetMinSize(wxSize(300, 300));

      // It might, on some systems, make more sense to choose a smaller size.
      // I'm not sure that makes sense on mobile platforms, however.
      frame->Maximize();

      d->frame_prom.set_value(frame);
      // d not deleted, on other threads stack.
    }

    void OnDelWebView(wxThreadEvent& event) {
      DelWVData *d = event.GetPayload<DelWVData *>();
      d->frame->Destroy();
      delete d;
    }
  };

  WVApp::WVApp() {
    // Keep the wx "main" thread running even without windows.
    SetExitOnFrameDelete(false);

    Bind(wxEVT_THREAD, &WVApp::OnDisplayURI, this, CMD_DISPLAY_URI);
    Bind(wxEVT_THREAD, &WVApp::OnRunScript, this, CMD_RUN_SCRIPT);
    Bind(wxEVT_THREAD, &WVApp::OnRegisterScheme, this, CMD_REGISTER_SCHEME);
    Bind(wxEVT_THREAD, &WVApp::OnRegisterClose, this, CMD_REGISTER_CLOSE);
    Bind(wxEVT_THREAD, &WVApp::OnRegisterAuxClose, this, CMD_REGISTER_AUX_CLOSE);
    Bind(wxEVT_THREAD, &WVApp::OnNewWebView, this, CMD_NEW_WEB_VIEW);
    Bind(wxEVT_THREAD, &WVApp::OnDelWebView, this, CMD_DEL_WEB_VIEW);
  }

  wxIMPLEMENT_APP_NO_MAIN(WVApp);

#if wxUSE_WEBVIEW_IE
  void EnableIEFeature(const wxChar *key_name, long value) {
    wxRegKey key(wxRegKey::HKCU, IE_EMULATION_KEY);
    if (!key.Exists())
      return;

    const wxString programName = wxGetFullModuleName().AfterLast('\\');
    key.SetValue(programName, value);
  }

  long GetIEVersion() {
    wxRegKey key(wxRegKey::HKLM, "Software\\Microsoft\\Internet Explorer");
    wxString value;
    if (!key.QueryValue("Version", value))
      return 0;

    long version = wxAtoi(value);
    if (version == 9) {
      // Version reports 9.x for all versions >= than 9. The real version is
      // in svcVersion for later versions. See:
      //   https://blogs.msdn.microsoft.com/ieinternals/2014/02/19/everybody-lies/
      if (key.QueryValue("svcVersion", value))
        version = wxAtoi(value);
    }

    return version;
  }

  void SetupIEFeatures() {
    // For additional information on these keys, see:
    //   https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/general-info/ee330720(v=vs.85)
    // By default, GPU acceleration is not enabled. Enable it for this application.
    EnableIEFeature("Software\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_GPU_RENDERING", 1);

    int IEVersion = GetIEVersion();
    if (IEVersion) {
      long EmulVal = IEVersion * 1000;

      // Disable emulation of previous browser versions (by selecting the current version). The default is IE7.
	  EnableIEFeature("Software\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_BROWSER_EMULATION", EmulVal);

      // Note that wxWebViewIE::MSWSetModernEmulationLevel only sets the emulation level to IE8, which is already old,
      // and does not set these other features.
    }

    // This feature is undocumented, unfortunately, but is discussed here:
    //   http://zett42.de/software/2013/04/04/performance-issue-of-embedded-ie-browser-control-and-how-to-fix-it/
    EnableIEFeature(L"Software\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_ALIGNED_TIMERS", 1);
  }
#endif // wxUSE_WEBVIEW_IE

  std::mutex WVThreadMutex;
  std::thread *WVThread = nullptr;

  bool WVInitDone = false;
  std::mutex WVInitMutex;
  std::condition_variable WVInitCV;

  void WVThreadMain() {
#ifdef __WINDOWS__
    // wxIMPLEMENT_WXWIN_MAIN does this as the first thing
    wxDISABLE_DEBUG_SUPPORT();

    wxInitializer wxinit;

#if wxUSE_WEBVIEW_IE
    SetupIEFeatures();
#endif

    std::unique_lock<std::mutex> iul(WVInitMutex);
    WVInitDone = true;
    iul.unlock();
    WVInitCV.notify_one();

    const HINSTANCE hInstance =
      wxDynamicLibrary::MSWGetModuleHandle("web_view_wx", (void *) &WVThread);
    if (!hInstance)
      wxEntry();
    else
      wxEntry(hInstance);
#else
  wxInitializer wxinit;

  std::unique_lock<std::mutex> iul(WVInitMutex);
  WVInitDone = true;
  iul.unlock();
  WVInitCV.notify_one();

  int argc = 0;
  wxChar* argv = NULL;

  wxEntry(argc, &argv);
#endif // __WINDOWS__
  }
} // anonymous namespace

namespace wv { namespace web_view_detail {
  struct WEB_VIEW_WX_EXPORT impl_wx : public impl {
    impl_wx(const std::string &title) {
      std::unique_lock<std::mutex> tul(WVThreadMutex);
      if (!WVThread) {
        std::unique_lock<std::mutex> iul(WVInitMutex);
        WVThread = new std::thread(WVThreadMain);
        WVInitCV.wait(iul, []{ return WVInitDone; } );
      }
      tul.unlock();

      NewWVData d;
      d.label = title;
      std::future<WVFrame *> new_frame = d.frame_prom.get_future();

      wxThreadEvent *event =
        new wxThreadEvent(wxEVT_THREAD, CMD_NEW_WEB_VIEW);
      event->SetPayload(&d);

      wxQueueEvent(wxApp::GetInstance(), event);
      frame = new_frame.get();
    }

    virtual ~impl_wx() override {
      DelWVData *d = new DelWVData;
      d->frame = frame;

      wxThreadEvent *event =
        new wxThreadEvent(wxEVT_THREAD, CMD_DEL_WEB_VIEW);
      event->SetPayload(d);

      wxQueueEvent(wxApp::GetInstance(), event);
    }

    virtual std::future<std::error_code> display_from_uri(const std::string &uri) override {
      DisplayURIData *d = new DisplayURIData;
      d->prom = new std::promise<std::error_code>;
      d->frame = frame;
      d->uri = uri;

      std::future<std::error_code> f = d->prom->get_future();
      wxThreadEvent *event =
        new wxThreadEvent(wxEVT_THREAD, CMD_DISPLAY_URI);
      event->SetPayload(d);

      wxQueueEvent(wxApp::GetInstance(), event);
      return f;
    }

    virtual std::future<std::string> run_script(const std::string &script) override {
      RunScriptData *d = new RunScriptData;
      d->prom = new std::promise<std::string>;
      d->frame = frame;
      d->script = script;

      std::future<std::string> f = d->prom->get_future();
      wxThreadEvent *event =
        new wxThreadEvent(wxEVT_THREAD, CMD_RUN_SCRIPT);
      event->SetPayload(d);

      wxQueueEvent(wxApp::GetInstance(), event);
      return f;
    }

    virtual void register_uri_scheme_handler(const std::string &scheme,
                                             HandlerFunc *func) override {
      RegSchemeData *d = new RegSchemeData;
      d->frame = frame;
      d->scheme = scheme;
      d->func = func;

      wxThreadEvent *event =
        new wxThreadEvent(wxEVT_THREAD, CMD_REGISTER_SCHEME);
      event->SetPayload(d);

      wxQueueEvent(wxApp::GetInstance(), event);

      // There maybe some schemes that can't be registered on some systems?
      // It's not clear what the right return type is here.
    }

    virtual void register_close_handler(CloseHandlerFunc *cfunc) override {
      RegCloseData *d = new RegCloseData;
      d->frame = frame;
      d->cfunc = cfunc;

      wxThreadEvent *event =
        new wxThreadEvent(wxEVT_THREAD, CMD_REGISTER_CLOSE);
      event->SetPayload(d);

      wxQueueEvent(wxApp::GetInstance(), event);
    }

    virtual void register_aux_close_handler(CloseHandlerFunc *cfunc) override {
      RegCloseData *d = new RegCloseData;
      d->frame = frame;
      d->cfunc = cfunc;

      wxThreadEvent *event =
        new wxThreadEvent(wxEVT_THREAD, CMD_REGISTER_AUX_CLOSE);
      event->SetPayload(d);

      wxQueueEvent(wxApp::GetInstance(), event);
    }

    virtual void request_close() override {
      frame->Close();
    };

    WVFrame *frame;
  };

  WEB_VIEW_WX_EXPORT impl *make_web_view_impl(const std::string &title) {
    return new impl_wx(title);
  }
} }


